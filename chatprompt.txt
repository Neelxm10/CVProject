GIven my code: 
import cv2 as cv
from matplotlib import pyplot as py
import numpy as np
import os
from imageProcessor import imageProcessor


## Import Sample video
filename = "IMG_8879.mov"
capture = cv.VideoCapture(filename)

#frame counter initialization
framecnt = 0
#make a directory called frame dump
if not os.path.exists:
    os.mkdir('Frame_Dump')
else:
    print("Directory already exists, proceeding with overwriting directory\n")
#while the video capture bit is true
while (capture.isOpened()):
    #store the state whether there is a frame or not, and record the frame data
    state,frame = capture.read()
    #if state is true (state == 1), process the image
    if state:
        framecnt+=1
        imageProcessor(frame,framecnt)
        print('FrameCount:'+str(framecnt)+'\n')
        
    #other wise end the program (if there is no frame, state == 0)  
    else:
        print("No remaining frames to process\n") 
        break




import cv2 as cv
from matplotlib import pyplot as plt
import numpy as np
import os
from ransac import ransac
#Currently converts image to HSV to test functionality. We can build algorithm here.

def imageProcessor(img, framecnt):
    print('processing image...\n')
    #show the original image
    cv.imshow('video reader', img)

    #Defining region of interest, middle of image:
    roi_x = img.shape[1] // 2  # Adjust as needed
    roi_y = img.shape[0] // 2 # Adjust as needed
    roi_width = img.shape[1] // 2  # Adjust as needed
    roi_height = img.shape[0]// 2# Adjust as needed

    #Applying ROI mask
    roi = img[roi_y:roi_y + roi_height, roi_x:roi_x + roi_width]

    #Convert to HSV and display HSV image frame by frame. 
    imgHSV= cv.cvtColor(roi, cv.COLOR_BGR2HSV)
   #Convert to grayscale
    imgHSVGS = cv.cvtColor(imgHSV, cv.COLOR_BGR2GRAY)
   
   #extract individual channels
    imgSat= imgHSV[:,:,1]
    imgVal = imgHSV[:,:,0]
    imgHue = imgHSV[:,:,2]
   
    #Apply initial binary mask using Saturation image channel
    ret, mask = cv.threshold(imgSat, 50, 150, cv.THRESH_BINARY)

    #create structuring element and use it to perform opening mask
    disc = cv.getStructuringElement(cv.MORPH_ELLIPSE, (7,7))
    
    #dilate, erode, and dilate again.
    dilated_mask = cv.dilate(mask, disc)
    eroded_mask = cv.erode(dilated_mask, disc, 10)
    dilate2 = cv.dilate(eroded_mask, disc, 10)
    #Subtract dilated mask from initial binary mask to retreive only the edges
    edges = cv.absdiff(mask, eroded_mask)

    #stack locations of edge detected pixels in the binary image
    edge_px = np.column_stack(np.where(edges>0))




    #lines = ransac(edge_px, 0.05, 10, 5)

    # Create an empty image to draw lines
    img_with_lines = edges.copy()

 #   if lines is not None:
   #     for line in lines:
    #        m, b = line
     #       x1 = 0
      #      y1 = int(b)
       #     x2 = img.shape[1] - 1  # Width of the image
       #     y2 = int(m * x2 + b)
                    # Ensure y1 and y2 are within the image boundaries
        #    y1 = max(0, min(y1, roi.shape[0] - 1))
        #    y2 = max(0, min(y2, roi.shape[0] - 1))
         #   cv.line(img_with_lines, (x1, y1), (x2, y2), (255, 255, 255), 2)
            #print(line)
    # Display images
    #cv.imshow('Original Image', img)
    cv.imshow('Masked image', mask)        
    cv.imshow('Edge Detection', edges)
    #cv.imshow('Region of Interest', roi)
    #cv.imshow('Image with Lines', img_with_lines)
    #cv.imwrite('Frame_Dump/Frame_' + str(framecnt) + '.png', img_with_lines)
    cv.waitKey(100)
    #With Edge detection performed now we get the contour lines

    
cv.destroyAllWindows()

def ransac(img, threshold, max_iterations, min_inline):
    #Preallocate variables
    best_fit = None
    best_inliers = 0
    num_points = np.sum(img)
    #Accumulator array
    detected_circles= []
    for i in range(max_iterations):
        #pick two random sample points to get slope info
        sample_indices = np.random.choice(num_points, size=3, replace=False)
        sample_points = np.column_stack(np.unravel_index(np.flatnonzero(img), img.shape))[sample_indices]

        if num_points < 3:
            continue
        # Ensure the sampled points are distinct
        if len(np.unique(sample_points, axis=0)) < 3:
            continue
        A, B, C = sample_points
        midABx, midABy = (A + B) / 2
        midBCx, midBCy = (B + C) / 2

        m_AB = (B[1] - A[1]) / (B[0] - A[0])
        intAB = A[1] - m_AB * A[0]
        m_BC = (C[1] - B[1]) / (C[0] - B[0])
        intBC = B[1] - m_BC * B[0]

        m_midAB = -1.0*m_AB
        m_midBC = -1.0*m_BC
        intMidAB = midABy - (m_midAB * midABx)
        intMidBC = midBCy - (m_midBC * midBCx)

        centerX = (intMidBC - intMidAB)/(m_midAB - m_midBC)
        centerY = (m_midAB * centerX) -intMidAB

        center = np.array([centerX, centerY])

        diffradiusx, diffradiusy = center - A

        radius = np.sqrt((diffradiusx*diffradiusx)+(diffradiusy*diffradiusy))
        circumference = 2.0 * 3.14 * radius


        #Compute line distance
        dist = np.sqrt(np.sum((sample_points - center)**2) - radius)
        print(str(dist)+ ' px\n')
        #identify inliers
        inline = img[dist < threshold]

        if len(inline) >= min_inline:
            detected_circles.append((center,radius))
    
    return detected_circles

Can you use the above code without changing it too much to generate a working ransac circle finding algorithm
    
